// Generated by CoffeeScript 1.10.0
(function() {
  var chai;

  if (typeof require !== "undefined" && require !== null) {
    chai = require('chai');
    global.should = chai.should();
    global.expect = chai.expect;
    global.localStorage = require('localStorage');
    chai.should();
    global.Fifo = require('../build/fifo').Fifo;
  }

  describe('Fifo', function() {
    var collection, limitReached, n100b, n100k, n10b, n10k, n1k, n1m, removedItem, removedItemForFifo, removedItemForFixedKey;
    this.timeout(25000);
    collection = null;
    n10b = null;
    n100b = null;
    n1k = null;
    n10k = null;
    n100k = null;
    n1m = null;
    limitReached = null;
    removedItem = null;
    removedItemForFixedKey = null;
    removedItemForFifo = null;
    beforeEach(function() {
      var e, error, repeat;
      try {
        localStorage.clear();
      } catch (error) {
        e = error;
      }
      repeat = function(value, count) {
        var output;
        output = [];
        while (count -= 1) {
          output.push(value);
        }
        return output.join('');
      };
      n10b = '1234567890';
      n100b = repeat(n10b, 10);
      n1k = repeat(n100b, 10);
      n10k = repeat(n1k, 10);
      n100k = repeat(n10k, 10);
      n1m = repeat(n100k, 10);
      return collection = new Fifo('fifo:test');
    });
    it("sets the default namespect to 'fifo'", function() {
      collection = new Fifo();
      return collection.namespace.should.equal('fifo');
    });
    it('set and get items in storage', function() {
      var retrieved;
      collection.set('foo', {
        foo: 'bar'
      });
      retrieved = collection.get('foo');
      return retrieved.foo.should.equal('bar');
    });
    it('will set noLS to true if there is localStorage', function() {
      return expect(collection.noLS).to.be["false"];
    });
    it('remove items from storage', function() {
      collection.set('foo', {
        foo: 'bar'
      });
      collection.remove('foo');
      return expect(collection.get('foo')).to.be.undefined;
    });
    if (typeof require === "undefined" || require === null) {
      it('ensure it removes old items to add others, sending them to onLimit', function() {
        var i, key, onLimit;
        limitReached = false;
        removedItem = null;
        i = 0;
        onLimit = function(items) {
          limitReached = true;
          return removedItem = items[0];
        };
        while (!(limitReached || i === 10000)) {
          i += 1;
          key = "test:" + i;
          collection.set(key, n100k, onLimit);
        }
        if (collection.noLS) {
          return expect(removedItem).to.be["null"];
        } else {
          return expect(removedItem.key).to.equal("test:1");
        }
      });
    }
    it('empty the collection', function() {
      collection.set('empty1', true);
      collection.set('empty2', true);
      collection.get('empty1').should.be["true"];
      collection.get('empty2').should.be["true"];
      collection.empty();
      expect(collection.get('empty1')).to.be.undefined;
      return expect(collection.get('empty2')).to.be.undefined;
    });
    it('add fixed value', function() {
      var fixed, fixedKey, fixedValue;
      fixedValue = 'value';
      fixedKey = 'fixed';
      collection.setFixed(fixedKey, fixedValue);
      fixed = collection.get(fixedKey);
      expect(fixed).to.equal(fixedValue);
      collection.remove(fixedKey);
      fixed = collection.get(fixedKey);
      return expect(fixed).to.be.undefined;
    });
    if (typeof require === "undefined" || require === null) {
      it('fixed keys can be added once FIFO queue full then add additional items to FIFO queue and check that we kept the fixed item', function() {
        var fifoQueueOnLimit, fixedKeyOnLimit, i, key, moreFifoOnLimit;
        if (collection.noLS) {
          return;
        }
        i = 0;
        limitReached = false;
        removedItem = null;
        removedItemForFixedKey = null;
        removedItemForFifo = null;
        moreFifoOnLimit = function(items) {
          return removedItemForFifo = items[0];
        };
        fixedKeyOnLimit = function(items) {
          removedItemForFixedKey = items[0];
          return collection.set(key, n1m, moreFifoOnLimit);
        };
        fifoQueueOnLimit = function(items) {
          limitReached = true;
          removedItem = items[0];
          return collection.setFixed('fixed-key', n1m, fixedKeyOnLimit);
        };
        while (!(limitReached || i === 100)) {
          i += 1;
          key = "test:" + i;
          collection.set(key, n100k, fifoQueueOnLimit);
        }
        expect(collection.get('fixed-key').length).to.equal(n1m.length);
        removedItem.key.should.equal('test:1');
        if (navigator.appVersion.indexOf("MSIE 8") === -1) {
          return;
        }
        if (navigator.appVersion.indexOf("MSIE 9") === -1) {
          return;
        }
        if (navigator.appVersion.indexOf("MSIE 10") === -1) {
          return;
        }
        removedItemForFixedKey.key.should.equal('test:2');
        return removedItemForFifo.key.should.equal('test:12');
      });
    }
    it('gets all values', function() {
      collection.setFixed('fixed-key', 'fixed-value');
      collection.set('fifo-key', 'fifo-value');
      expect(Object.keys(collection.get()).length).to.equal(2);
      collection.get()['fifo-key'].should.equal('fifo-value');
      return collection.get()['fixed-key'].should.equal('fixed-value');
    });
    it('get keys', function() {
      collection.setFixed('fixed-key', 'fixed-value');
      collection.set('fifo-key', 'fifo-value');
      expect(collection.keys().length).to.equal(2);
      expect(collection.keys()[0]).to.equal('fifo-key');
      return expect(collection.keys()[1]).to.equal('fixed-key');
    });
    it('has key', function() {
      collection.setFixed('fixed-key', 'fixed-value');
      collection.set('fifo-key', 'fifo-value');
      collection.has('fixed-key').should.be["true"];
      collection.has('fifo-key').should.be["true"];
      return collection.has('lose-key').should.be["false"];
    });
    it("'keys' isn't replicated due to pass by reference", function() {
      collection.setFixed('fixed-key', 'fixed-value');
      collection.set('fifo-key', 'fifo-value');
      collection.keys();
      return expect(collection.keys().length).to.equal(2);
    });
    it('test old key is cleaned up when saved', function() {
      collection.set('A', '1');
      collection.set('B', '2');
      collection.set('C', '3');
      expect(collection.keys().length).to.equal(3);
      collection.set('A', '4');
      return expect(collection.keys().length).to.equal(3);
    });
    it('can remove items using a string', function() {
      collection.setFixed('fixed-key', 'fixed-value');
      collection.setFixed('fixed-regex-key', 'fixed-regex-value');
      collection.set('fifo-regex-key', 'fifo-value');
      collection.set('fifo-key', 'fifo-regex-value');
      collection.remove('fixed-regex-key');
      collection.remove('fifo-regex-key');
      collection.has('fixed-key').should.be["true"];
      collection.has('fixed-regex-key').should.be["false"];
      collection.has('fifo-key').should.be["true"];
      return collection.has('fifo-regex-key').should.be["false"];
    });
    it('can remove items using a regex', function() {
      collection.setFixed('fixed-key', 'fixed-value');
      collection.setFixed('fixed-regex-key', 'fixed-regex-value');
      collection.set('fifo-regex-key', 'fifo-value');
      collection.set('fifo-key', 'fifo-regex-value');
      collection.remove(/regex/ig);
      collection.has('fixed-key').should.be["true"];
      collection.has('fixed-regex-key').should.be["false"];
      collection.has('fifo-key').should.be["true"];
      return collection.has('fifo-regex-key').should.be["false"];
    });
    it('can remove items using a function', function() {
      collection.setQueueLimit(null);
      collection.setFixed('fixed-key', 'fixed-value');
      collection.setFixed('fixed-regex-key', 'fixed-regex-value');
      collection.set('fifo-regex-key', 'fifo-value');
      collection.set('fifo-key', 'fifo-regex-value');
      collection.remove(function(value) {
        return value.indexOf('regex') !== -1;
      });
      collection.has('fixed-key').should.be["true"];
      collection.has('fixed-regex-key').should.be["false"];
      collection.has('fifo-key').should.be["true"];
      return collection.has('fifo-regex-key').should.be["false"];
    });
    it('can limit the fifo queue size', function() {
      collection.setQueueLimit(3);
      collection.set('key1', 'value1');
      collection.set('key2', 'value2');
      collection.set('key3', 'value3');
      collection.set('key4', 'value4');
      collection.set('key5', 'value5');
      collection.set('key6', 'value6');
      expect(collection.keys().length).to.equal(3);
      collection.has('key6').should.be["true"];
      collection.has('key5').should.be["true"];
      collection.has('key4').should.be["true"];
      return collection.has('key3').should.be["false"];
    });
    return describe('No localStorage', function() {
      beforeEach(function() {
        return collection.noLS = true;
      });
      if (typeof require !== "undefined" && require !== null) {
        it('will set noLS to false if there is no localStorage', function() {
          var cached_local_storage, test;
          cached_local_storage = global.localStorage;
          global.localStorage = void 0;
          try {
            test = new Fifo('fifo:test');
            return expect(test.noLS).to.be["true"];
          } finally {
            global.localStorage = cached_local_storage;
          }
        });
      }
      it('will return false when trying to invoke trySave with no localStorage', function() {
        return expect(collection.trySave()).to.be["false"];
      });
      it('will return removed items when trying to invoke save with no localStorage', function() {
        return expect(collection.save()).to.eql([]);
      });
      it('set and get items with a key in storage with no localStorage', function() {
        var retrieved;
        collection.set('foo', {
          foo: 'bar'
        });
        retrieved = collection.get('foo');
        return retrieved.foo.should.equal('bar');
      });
      it('set and get items without a key in storage with no localStorage', function() {
        var retrieved, test;
        test = {
          foo: 'bar'
        };
        collection.set('foo', test);
        retrieved = collection.get();
        return retrieved.foo.should.equal(test);
      });
      it('add fixed value with no localStorage', function() {
        var fixed, fixedKey, fixedValue;
        fixedValue = 'value';
        fixedKey = 'fixed';
        collection.setFixed(fixedKey, fixedValue);
        fixed = collection.get(fixedKey);
        expect(fixed).to.equal(fixedValue);
        collection.remove(fixedKey);
        fixed = collection.get(fixedKey);
        return expect(fixed).to.be.undefined;
      });
      it('get keys with no localStorage', function() {
        collection.setFixed('fixed-key', 'fixed-value');
        collection.set('fifo-key', 'fifo-value');
        expect(collection.keys().length).to.equal(2);
        expect(collection.keys()[0]).to.equal('fifo-key');
        return expect(collection.keys()[1]).to.equal('fixed-key');
      });
      it('get keys with no localStorage and queue limit set', function() {
        collection.setQueueLimit(4);
        collection.set('fifo-key-1', 'fifo-value-1');
        collection.setFixed('fifo-key-2', 'fifo-value-2');
        collection.set('fifo-key-3', 'fifo-value-3');
        collection.setFixed('fifo-key-4', 'fifo-value-4');
        collection.set('fifo-key-5', 'fifo-value-5');
        collection.setFixed('fifo-key-6', 'fifo-value-6');
        collection.set('fifo-key-7', 'fifo-value-7');
        collection.setFixed('fifo-key-8', 'fifo-value-8');
        expect(collection.keys().length).to.equal(4);
        expect(collection.keys()[0]).to.equal('fifo-key-8');
        expect(collection.keys()[1]).to.equal('fifo-key-7');
        expect(collection.keys()[2]).to.equal('fifo-key-6');
        return expect(collection.keys()[3]).to.equal('fifo-key-5');
      });
      it('has key with no localStorage', function() {
        collection.setFixed('fixed-key', 'fixed-value');
        collection.set('fifo-key', 'fifo-value');
        collection.has('fixed-key').should.be["true"];
        collection.has('fifo-key').should.be["true"];
        return collection.has('lose-key').should.be["false"];
      });
      it('has key with no localStorage and queue limit set', function() {
        collection.setQueueLimit(4);
        collection.set('fifo-key-1', 'fifo-value-1');
        collection.setFixed('fifo-key-2', 'fifo-value-2');
        collection.set('fifo-key-3', 'fifo-value-3');
        collection.setFixed('fifo-key-4', 'fifo-value-4');
        collection.set('fifo-key-5', 'fifo-value-5');
        collection.setFixed('fifo-key-6', 'fifo-value-6');
        collection.set('fifo-key-7', 'fifo-value-7');
        collection.setFixed('fifo-key-8', 'fifo-value-8');
        collection.has('fifo-key-8').should.be["true"];
        collection.has('fifo-key-7').should.be["true"];
        return collection.has('fifo-key-4').should.be["false"];
      });
      it('can remove items using a regex with no localStorage', function() {
        collection.setFixed('fixed-key', 'fixed-value');
        collection.setFixed('fixed-regex-key', 'fixed-regex-value');
        collection.set('fifo-regex-key', 'fifo-value');
        collection.set('fifo-key', 'fifo-regex-value');
        collection.remove(/regex/ig);
        collection.has('fixed-key').should.be["true"];
        collection.has('fixed-regex-key').should.be["false"];
        collection.has('fifo-key').should.be["true"];
        return collection.has('fifo-regex-key').should.be["false"];
      });
      return it('can remove items using a function', function() {
        collection.setQueueLimit(null);
        collection.setFixed('fixed-key', 'fixed-value');
        collection.setFixed('fixed-regex-key', 'fixed-regex-value');
        collection.set('fifo-regex-key', 'fifo-value');
        collection.set('fifo-key', 'fifo-regex-value');
        collection.remove(function(value) {
          return value.indexOf('regex') !== -1;
        });
        collection.has('fixed-key').should.be["true"];
        collection.has('fixed-regex-key').should.be["false"];
        collection.has('fifo-key').should.be["true"];
        return collection.has('fifo-regex-key').should.be["false"];
      });
    });
  });

}).call(this);
